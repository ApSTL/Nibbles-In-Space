<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hohmann Transfer Calculator</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Anta&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
    
    <style>
        /* --- General Body and Font Styles --- */
		body { 
            margin: 0; 
            font-family: "Roboto Mono", monospace;
            font-optical-sizing: auto;
            font-weight: 400;
            font-style: normal;
            font-size: 14px;
            line-height: 80%;
            background-color: #000; 
            color: #fff; 
            overflow: hidden; /* Prevents scrollbars */
        }
        
        /* --- Main Control Panel (Left Side) --- */
        #panel-container {
            position: absolute; 
			top: 0px;
            left: 0; 
			z-index: 10; 
            display: flex;
            align-items: flex-start;
            flex-shrink: 0;
        }

        #info {
            width: 300px;
            max-height: calc(100vh - 25px); 
            overflow-y: auto; 
            margin: 5px;
			margin-left: 15px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.1); 
            border-radius: 10px;
            backdrop-filter: blur(3px); 
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
            border: 1px solid rgba(190, 153, 5, 1); 
            transition: all 0.35s ease-in-out;
            transform: translateX(0); 
        }

        /* Collapsed state for the panel */
        #info.collapsed {
            transform: translateX(-100%); 
            width: 0px;
            padding-left: 0;
            padding-right: 0;
            margin-left: 0;
            overflow-x: hidden;
        }

        /* --- Panel Toggle Button (Arrow) --- */
        #toggle-button {
            position: absolute;
            top: 2%;
            left: 100%; 
            transform: translateX(0);
            width: 48px;
            height: 48px;
            padding: 0;
            padding-left: 2px;
            background: #BE9905;
            border: 0px solid #666;
            border-left: none;
            color: white;
            cursor: pointer;
            border-radius: 0 8px 8px 0;
            font-size: 1.0em;
            line-height: 48px;
            text-align: center;
            z-index: 10;
            transition: all 0.35s ease-in-out;
        }

        /* Style for toggle button when panel is collapsed */
        #info.collapsed + #toggle-button {
            transform: translateX(-10%) translateY(250%);
			background: #ed1248; 
        }
        
        /* --- Panel Content: Headers & Controls --- */
        h1 {
            margin-top: 0; 
            font-size: 1.8em; 
            text-align: center; 
            color: #BE9905; 
			font-family: "Anta", sans-serif;
			font-weight: 400;
			font-style: normal;
			line-height: 120%;
		}
        h2 { 
            font-size: 0.9em; 
            color: #BE9905; 
            text-transform: uppercase; 
            letter-spacing: 1px; 
            margin-top: 20px; 
            margin-bottom: 10px; 
            border-bottom: 1px solid #444; 
            padding-bottom: 5px;
			line-height: 120%;
			font-family: "Anta", sans-serif;
			font-weight: 400;
			font-style: normal;
		}
        .control-group { margin-bottom: 12px; }
        label { 
            display: flex; 
            justify-content: space-between;
            margin-bottom: 5px; 
            font-weight: bold; 
            font-size: 0.9em; 
        }
        label span.unit {
            font-weight: normal;
            color: #aaa;
        }
        
        /* Number Input */
        input[type="number"] {
            width: 100%;
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 5px;
            font-family: "Roboto Mono", monospace;
            box-sizing: border-box; 
            font-size: 0.9em;
        }
        
        /* Select Dropdown */
        select {
            width: 100%;
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 5px;
            font-family: "Roboto Mono", monospace;
            box-sizing: border-box;
            font-size: 0.9em;
        }

        /* Satellite State Display List */
        .display-item { 
            display: flex; 
            justify-content: space-between; 
            font-size: 0.9em; 
            padding: 5px 0; 
            border-bottom: 1px solid #333; 
        }
        .display-item:last-child { border-bottom: none; }
        .display-label { color: #aaa; }
        .display-value { font-weight: bold; }
        
        /* Warning Box */
        .warning { 
            font-size: 0.85em; 
            font-weight: bold; 
            text-align: center; 
            padding: 6px; 
            margin-top: 5px; 
            border-radius: 4px; 
            display: none; 
            line-height: 1.4;
        }
        .warning.red { display: block; background-color: #5d1a1a; color: #ff5252; }
        .warning.amber { display: block; background-color: #5d4500; color: #ffc107; }
        
        .display-group { margin-bottom: 12px; } 

        /* --- Map Container & SVG --- */
        #viz-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            min-width: 0;
        }

        #viz-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent; 
        }

        /* --- Visualization Element Styles --- */
        .central-body {
            /* fill is set by JS */
            stroke: #fff;
            stroke-width: 1px;
        }

        .orbit-path {
            fill: none;
            stroke-width: 1.5px;
            stroke-dasharray: 4, 4;
            display: none; 
        }
        
        .orbit-initial {
            stroke: #BE9905; 
            stroke-dasharray: none;
        }

        .orbit-target {
            stroke: #ed1248; 
			stroke-dasharray: none;
        }

        .orbit-transfer {
            stroke: #1a5dad; 
        }

        .burn-point {
            fill: #BE9905;
            stroke: #fff;
            stroke-width: 1.5px;
            display: none; 
        }
        
        /* Standard Button */
        .sim-button {
            width: 100%;
            padding: 10px;
            background-color: #BE9905;
            color: #000;
            border: none;
            border-radius: 5px;
            font-family: "Roboto Mono", monospace;
            font-weight: bold;
            font-size: 1em;
            cursor: pointer;
            margin-top: 10px;
        }
        .sim-button:hover {
            background-color: #ffd966; 
        }
        .sim-button:disabled {
            background-color: #555;
            color: #999;
            cursor: not-allowed;
        }
    </style>
</head>
<body>

<div id="panel-container">
    
    <div id="info">
        <h1>Hohmann Transfer</h1>
        
        <h2>CENTRAL BODY</h2>
        <div class="control-group">
            <label for="central-body-select"></label>
            <select id="central-body-select">
                <option value="earth">Earth</option>
                <option value="moon">Moon</option>
                <option value="mercury">Mercury</option>
                <option value="venus">Venus</option>
                <option value="mars">Mars</option>
                <option value="jupiter">Jupiter</option>
                <option value="saturn">Saturn</option>
                <option value="uranus">Uranus</option>
                <option value="neptune">Neptune</option>
                <option value="custom">Custom...</option>
            </select>
        </div>
        <div class="display-group" style="margin-bottom: 0;">
            <div class="display-item"><span class="display-label">Body Mass</span><span class="display-value" id="body-mass-val">N/A</span></div>
            <div class="display-item"><span class="display-label" id="body-peri-label">Periapsis</span><span class="display-value" id="body-peri-val">N/A</span></div>
            <div class="display-item"><span class="display-label" id="body-apo-label">Apoapsis</span><span class="display-value" id="body-apo-val">N/A</span></div>
            <div class="display-item"><span class="display-label">Sphere of Influence</span><span class="display-value" id="body-soi-val">N/A</span></div>
        </div>
        <div class="control-group" id="custom-body-group" style="display: none;">
            <label for="custom-mass" style="margin-top: 10px;">Custom Mass <span class="unit">kg</span></label>
            <input type="number" id="custom-mass" value="5.972e24">
            <label for="custom-radius" style="margin-top: 10px;">Custom Radius <span class="unit">km</span></label>
            <input type="number" id="custom-radius" value="6378.137">
            <label for="custom-peri-au" style="margin-top: 10px;">Perihelion <span class="unit">au</span></label>
            <input type="number" id="custom-peri-au" value="1.0">
            <label for="custom-apo-au" style="margin-top: 10px;">Aphelion <span class="unit">au</span></label>
            <input type="number" id="custom-apo-au" value="1.0">
        </div>
        
        <h2>ORBIT INPUTS</h2>
        <div class="control-group">
            <label for="init-periapsis">Initial Periapsis (Alt) <span class="unit">km</span></label>
            <input type="number" id="init-periapsis" value="850">
        </div>
        <div class="control-group">
            <label for="init-apoapsis">Initial Apoapsis (Alt) <span class="unit">km</span></label>
            <input type="number" id="init-apoapsis" value="850">
        </div>
        <div class="control-group">
            <label for="target-periapsis">Target Periapsis (Alt) <span class="unit">km</span></label>
            <input type="number" id="target-periapsis" value="35786">
        </div>
        <div class="control-group">
            <label for="target-apoapsis">Target Apoapsis (Alt) <span class="unit">km</span></label>
            <input type="number" id="target-apoapsis" value="35786">
        </div>
        
        <h2>ROCKET INPUTS</h2>
         <div class="control-group">
            <label for="final-mass">Final Mass <span class="unit">kg</span></label>
            <input type="number" id="final-mass" value="1000">
        </div>
         <div class="control-group">
            <label for="isp">Specific Impulse (Isp) <span class="unit">s</span></label>
            <input type="number" id="isp" value="300">
        </div>
        
        
        <button id="calc-btn" class="sim-button">Calculate Transfer</button>
        <div id="calc-warning" class="warning"></div>
        <div id="bi-elliptic-warning" class="warning"></div>
        
        <h2>RESULTS</h2>
        <div class="display-group">
            <div class="display-item"><span class="display-label">Transfer Type</span><span class="display-value" id="type-val">N/A</span></div>
            <div class="display-item"><span class="display-label">Burn 1 (Δv₁)</span><span class="display-value" id="dv1-val">N/A</span></div>
            <div class="display-item"><span class="display-label">Burn 2 (Δv₂)</span><span class="display-value" id="dv2-val">N/A</span></div>
            <div class="display-item"><span class="display-label">Total (Δv)</span><span class="display-value" id="total-dv-val">N/A</span></div>
            <div class="display-item"><span class="display-label">Transfer Time</span><span class="display-value" id="time-val">N/A</span></div>
        
            <div class="display-item"><span class="display-label">Propellant Mass</span><span class="display-value" id="prop-mass-val">N/A</span></div>
            <div class="display-item"><span class="display-label">Initial Mass</span><span class="display-value" id="init-mass-val">N/A</span></div>
        </div>
            
    </div> <button id="toggle-button" title="Toggle Controls">◀</button>
    
</div> <div id="viz-container">
    <svg id="viz-svg">
        <g id="viz-group">
            <circle id="central-body" class="central-body" cx="0" cy="0" r="6378"></circle>
            
            <g id="orbit-layer">
                <ellipse id="orbit-initial" class="orbit-path orbit-initial"></ellipse>
                <ellipse id="orbit-target" class="orbit-path orbit-target"></ellipse>
                <ellipse id="orbit-transfer" class="orbit-path orbit-transfer"></ellipse>
            </g>
            
            <g id="burn-layer">
                <circle id="burn-1" class="burn-point" r="7"></circle>
                <circle id="burn-2" class="burn-point" r="7"></circle>
            </g>
        </g>
    </svg>
</div>

<script>
    'use strict'; 

    // --- Application Constants ---
    
    // Gravitational constant (N * (m/kg)^2)
    const G_CONST = 6.67430e-11; 
    // Standard gravity (m/s^2) used for specific impulse (Isp) calculation
    const G0 = 9.80665; 
    // Mass of the Sun (kg) for calculating custom body Sphere of Influence (SOI)
    const SUN_MASS_KG = 1.989e30;
    // Astronomical Unit to Kilometers conversion factor
    const AU_TO_KM = 149597870.7;
    
    // Data for pre-defined central bodies
    const CENTRAL_BODIES = {
        // name: { name, mass_kg, radius_km, peri_au/r_p_km, apo_au/r_a_km, soi_km, color }
        // For planets, peri/apo are their orbital distance from the Sun in AU (Perihelion/Aphelion)
        // For the Moon, peri/apo are Perigee/Apogee from Earth in km
        "earth":   { name: "Earth",   mass_kg: 5.972e24,  radius_km: 6378.137, peri_val: 0.983, apo_val: 1.017, soi_km: 925000,   color: "#336699" },
        "moon":    { name: "Moon",    mass_kg: 7.347e22,  radius_km: 1737.4,   peri_val: 363300,  apo_val: 405500,  soi_km: 66100,    color: "#aaaaaa" },
        "mercury": { name: "Mercury", mass_kg: 3.301e23,  radius_km: 2439.7,   peri_val: 0.307, apo_val: 0.467, soi_km: 112000,   color: "#b0a08a" },
        "venus":   { name: "Venus",   mass_kg: 4.867e24,  radius_km: 6051.8,   peri_val: 0.718, apo_val: 0.728, soi_km: 616000,   color: "#d0c0a0" },
        "mars":    { name: "Mars",    mass_kg: 6.417e23,  radius_km: 3389.5,   peri_val: 1.382, apo_val: 1.666, soi_km: 577000,   color: "#c1440e" },
        "jupiter": { name: "Jupiter", mass_kg: 1.898e27,  radius_km: 69911,    peri_val: 4.950, apo_val: 5.458, soi_km: 48200000, color: "#c0a080" },
        "saturn":  { name: "Saturn",  mass_kg: 5.683e26,  radius_km: 58232,    peri_val: 9.048, apo_val: 10.12, soi_km: 54800000, color: "#f0d0a0" },
        "uranus":  { name: "Uranus",  mass_kg: 8.681e25,  radius_km: 25362,    peri_val: 18.38, apo_val: 20.08, soi_km: 51800000, color: "#a0c0c0" },
        "neptune": { name: "Neptune", mass_kg: 1.024e26,  radius_km: 24622,    peri_val: 29.77, apo_val: 30.44, soi_km: 86800000, color: "#4060c0" },
        "custom":  { name: "Custom",  mass_kg: 5.972e24,  radius_km: 6378.137, peri_val: 1.0,   apo_val: 1.0,   soi_km: 0,        color: "#BE9905" } 
    };


    // --- Global State ---
    
    let g_scale = 1; // Global visualization scale (pixels per km)
    let g_transferData = null; // Stores results and visualization parameters
    
    // Dynamic physics parameters for the currently selected central body
    let CURRENT_BODY_RADIUS_KM;
    let CURRENT_GM_M3_S2; // Gravitational parameter (GM = G * Mass) in m^3/s^2

    /**
     * Cache of all DOM elements.
     */
    const dom = {
        infoDiv: document.getElementById('info'),
        toggleButton: document.getElementById('toggle-button'),
        vizContainer: document.getElementById('viz-container'),
        vizSvg: document.getElementById('viz-svg'),
        vizGroup: document.getElementById('viz-group'),
        
        // Central Body
        centralBodySelect: document.getElementById('central-body-select'),
        bodyMassVal: document.getElementById('body-mass-val'),
        bodyPeriLabel: document.getElementById('body-peri-label'),
        bodyPeriVal: document.getElementById('body-peri-val'),
        bodyApoLabel: document.getElementById('body-apo-label'),
        bodyApoVal: document.getElementById('body-apo-val'),
        bodySoiVal: document.getElementById('body-soi-val'),
        customBodyGroup: document.getElementById('custom-body-group'),
        customMassInput: document.getElementById('custom-mass'),
        customRadiusInput: document.getElementById('custom-radius'),
        customPeriAuInput: document.getElementById('custom-peri-au'),
        customApoAuInput: document.getElementById('custom-apo-au'),
        
        // Inputs
        initPeriapsis: document.getElementById('init-periapsis'),
        initApoapsis: document.getElementById('init-apoapsis'),
        targetPeriapsis: document.getElementById('target-periapsis'),
        targetApoapsis: document.getElementById('target-apoapsis'),
        finalMass: document.getElementById('final-mass'),
        isp: document.getElementById('isp'),
        
        // Warnings/Buttons
        calcBtn: document.getElementById('calc-btn'),
        warning: document.getElementById('calc-warning'),
        biEllipticWarning: document.getElementById('bi-elliptic-warning'),
        
        // Results
        typeVal: document.getElementById('type-val'),
        dv1Val: document.getElementById('dv1-val'),
        dv2Val: document.getElementById('dv2-val'),
        totalDvVal: document.getElementById('total-dv-val'),
        timeVal: document.getElementById('time-val'),
        propMassVal: document.getElementById('prop-mass-val'),
        initMassVal: document.getElementById('init-mass-val'),

        // SVG Elements
        centralBody: document.getElementById('central-body'),
        orbitInitial: document.getElementById('orbit-initial'),
        orbitTarget: document.getElementById('orbit-target'),
        orbitTransfer: document.getElementById('orbit-transfer'),
        burn1: document.getElementById('burn-1'),
        burn2: document.getElementById('burn-2')
    };

    /**
     * Calculates the velocity at a given radius in an orbit.
     * v = sqrt(GM * (2/r - 1/a))
     * @param {number} r_m - Current radius from center (meters).
     * @param {number} a_m - Semi-major axis of orbit (meters). Use Infinity for escape velocity.
     * @returns {number} Velocity in m/s.
     */
    function getVelocity(r_m, a_m) {
        return Math.sqrt(CURRENT_GM_M3_S2 * ((2 / r_m) - (1 / a_m)));
    }
    
    /**
     * Calculates the total Delta-V for a bi-elliptic transfer.
     * @param {number} r_A - Radius of the first burn point (meters).
     * @param {number} v_A_initial - Velocity in the initial orbit at r_A (m/s).
     * @param {number} r_D - Radius of the third burn point (meters).
     * @param {number} v_D_final - Velocity in the final orbit at r_D (m/s).
     * @param {number} rb - The intermediate apoapsis radius (meters).
     * @param {number} mu - Gravitational parameter (GM) (m^3/s^2).
     * @returns {number} Total Delta-V (m/s). Returns Infinity if transfer is geometrically invalid.
     */
    function getBiEllipticDV(r_A, v_A_initial, r_D, v_D_final, rb, mu) {
        if (rb <= Math.max(r_A, r_D)) { 
            return Infinity; 
        }
        
        const a_t1 = (r_A + rb) / 2; // Semi-major axis of first transfer ellipse
        const a_t2 = (r_D + rb) / 2; // Semi-major axis of second transfer ellipse
        
        // Calculate velocities on the transfer ellipses
        const v_t1_A = Math.sqrt(mu * ((2 / r_A) - (1 / a_t1))); 
        const v_t1_B = Math.sqrt(mu * ((2 / rb) - (1 / a_t1))); 
        const v_t2_B = Math.sqrt(mu * ((2 / rb) - (1 / a_t2))); 
        const v_t2_D = Math.sqrt(mu * ((2 / r_D) - (1 / a_t2))); 
        
        // Calculate the three burns
        const dv1 = Math.abs(v_t1_A - v_A_initial); // Burn 1 (at r_A)
        const dv2 = Math.abs(v_t2_B - v_t1_B);     // Burn 2 (at intermediate apoapsis rb)
        const dv3 = Math.abs(v_t2_D - v_D_final);     // Burn 3 (at r_D)
        
        return dv1 + dv2 + dv3;
    }
    
    /**
     * Calculates the total time for a bi-elliptic transfer.
     * Time = Pi * sqrt(a_t1^3 / GM) + Pi * sqrt(a_t2^3 / GM)
     * @param {number} r_A - Radius of the first burn (meters).
     * @param {number} r_D - Radius of the third burn (meters).
     * @param {number} rb - The intermediate apoapsis radius (meters).
     * @param {number} mu - Gravitational parameter (GM) (m^3/s^2).
     * @returns {number} Total time in seconds.
     */
    function getBiEllipticTime_s(r_A, r_D, rb, mu) {
        const a_t1 = (r_A + rb) / 2;
        const a_t2 = (r_D + rb) / 2;
        const time1 = Math.PI * Math.sqrt(Math.pow(a_t1, 3) / mu); // time for 1st half-ellipse
        const time2 = Math.PI * Math.sqrt(Math.pow(a_t2, 3) / mu); // time for 2nd half-ellipse
        return time1 + time2;
    }


    /**
     * Main initialization function.
     */
    function init() {
        setupUI();
        updateCentralBody(); // Set initial body (Earth)
        onWindowResize(); // Set initial size and center map
        calculateAndDraw(); // Run with default values
    }
    
    /**
     * Updates the current central body physics and UI display.
     */
    function updateCentralBody() {
        const selectedKey = dom.centralBodySelect.value;
        let body;
        let peri_val, apo_val, peri_label, apo_label, soi_val_km;

        if (selectedKey === "custom") {
            dom.customBodyGroup.style.display = 'block';
            
            // Read custom values from inputs
            const mass_kg = parseFloat(dom.customMassInput.value) || CENTRAL_BODIES.earth.mass_kg;
            const radius_km = parseFloat(dom.customRadiusInput.value) || CENTRAL_BODIES.earth.radius_km;
            const peri_au = parseFloat(dom.customPeriAuInput.value) || 1.0;
            const apo_au = parseFloat(dom.customApoAuInput.value) || 1.0;
            
            body = CENTRAL_BODIES.custom;
            body.mass_kg = mass_kg;
            body.radius_km = radius_km;
            
            // Calculate SOI for custom body (assumes orbit around the Sun)
            // SOI ≈ a * (m / M_sun)^(2/5)
            const a_au = (peri_au + apo_au) / 2.0;
            const a_km = a_au * AU_TO_KM;
            const soi_km = a_km * Math.pow(mass_kg / SUN_MASS_KG, 0.4);
            
            // Set display values for custom body's orbit
            peri_val = `${peri_au.toFixed(3)} au`;
            apo_val = `${apo_au.toFixed(3)} au`;
            peri_label = "Perihelion";
            apo_label = "Aphelion";
            soi_val_km = soi_km;

        } else {
            dom.customBodyGroup.style.display = 'none';
            body = CENTRAL_BODIES[selectedKey];
            
            if (selectedKey === "moon") {
                // Moon orbits Earth: display distance in km and use Perigee/Apogee labels
                peri_val = `${(body.peri_val / 1000).toFixed(0)}k km`;
                apo_val = `${(body.apo_val / 1000).toFixed(0)}k km`;
                peri_label = "Perigee";
                apo_label = "Apogee";
            } else {
                // Planets orbit Sun: display distance in AU and use Perihelion/Aphelion labels
                peri_val = `${body.peri_val.toFixed(3)} au`;
                apo_val = `${body.apo_val.toFixed(3)} au`;
                peri_label = "Perihelion";
                apo_label = "Aphelion";
            }
            soi_val_km = body.soi_km;
        }
        
        // Update global physics variables
        CURRENT_BODY_RADIUS_KM = body.radius_km;
        CURRENT_GM_M3_S2 = G_CONST * body.mass_kg;
        
        // Update the display panel
        dom.bodyMassVal.textContent = `${body.mass_kg.toExponential(3)} kg`;
        dom.bodyPeriLabel.textContent = peri_label;
        dom.bodyPeriVal.textContent = peri_val;
        dom.bodyApoLabel.textContent = apo_label;
        dom.bodyApoVal.textContent = apo_val;
        dom.bodySoiVal.textContent = `${(soi_val_km / 1000).toFixed(0)}k km`;
        
        // Update visualization color and size
        dom.centralBody.style.fill = body.color;
        dom.centralBody.setAttribute('r', CURRENT_BODY_RADIUS_KM * g_scale);
        
        // Clear old results as physics constants have changed
        clearResults();
    }


    /**
     * Sets up all UI event listeners for interaction and data input.
     */
    function setupUI() {
        // Toggle the control panel visibility
        dom.toggleButton.addEventListener('click', () => {
            dom.infoDiv.classList.toggle('collapsed');
            dom.toggleButton.textContent = dom.infoDiv.classList.contains('collapsed') ? '▶' : '◀';
        });

        // Recalculate scale and redraw on window resize
        window.addEventListener('resize', onWindowResize);
        
        // Main calculation trigger
        dom.calcBtn.addEventListener('click', calculateAndDraw);
        
        // Listen for changes to central body selection or custom inputs
        dom.centralBodySelect.addEventListener('change', updateCentralBody);
        dom.customMassInput.addEventListener('input', updateCentralBody);
        dom.customRadiusInput.addEventListener('input', updateCentralBody);
        dom.customPeriAuInput.addEventListener('input', updateCentralBody);
        dom.customApoAuInput.addEventListener('input', updateCentralBody);
        
        // Clear results when orbit or rocket inputs change
        const inputs = [dom.initPeriapsis, dom.initApoapsis, dom.targetPeriapsis, dom.targetApoapsis, dom.finalMass, dom.isp];
        inputs.forEach(input => {
            input.addEventListener('input', clearResults);
        });
    }

    /**
     * Resets all calculated results and hides the visualization elements.
     */
    function clearResults() {
        // Reset displayed values
        dom.typeVal.textContent = 'N/A';
        dom.dv1Val.textContent = 'N/A';
        dom.dv2Val.textContent = 'N/A';
        dom.totalDvVal.textContent = 'N/A';
        dom.timeVal.textContent = 'N/A';
        dom.propMassVal.textContent = 'N/A';
        dom.initMassVal.textContent = 'N/A';
        
        // Hide warnings
        dom.warning.className = 'warning';
        dom.warning.textContent = '';
        dom.biEllipticWarning.style.display = 'none';
        dom.biEllipticWarning.textContent = '';
        
        g_transferData = null; // Clear calculation data
        
        // Hide SVG orbits and burns
        dom.orbitInitial.style.display = 'none';
        dom.orbitTarget.style.display = 'none';
        dom.orbitTransfer.style.display = 'none';
        dom.burn1.style.display = 'none';
        dom.burn2.style.display = 'none';
    }

    /**
     * Adjusts the SVG canvas and visualization group translation on window resize.
     */
    function onWindowResize() {
        const w = dom.vizContainer.clientWidth;
        const h = dom.vizContainer.clientHeight;
        
        dom.vizSvg.setAttribute("width", w);
        dom.vizSvg.setAttribute("height", h);
        
        // Center the visualization group at the center of the SVG
        dom.vizGroup.setAttribute("transform", `translate(${w / 2}, ${h / 2})`);
        
        // Recalculate scale and redraw if data exists
        if (g_transferData) {
            updateScaleAndRedraw();
        }
    }

    /**
     * Determines the optimal global scale factor and calls the redraw function.
     */
    function updateScaleAndRedraw() {
        if (!g_transferData) return;

        const w = dom.vizContainer.clientWidth;
        const h = dom.vizContainer.clientHeight;

        // Determine the maximum orbital radius (in km) to be displayed
        const max_r_km = Math.max(
            g_transferData.r_a1_km, 
            g_transferData.r_a2_km, 
            g_transferData.r_a_t_km
        );

        // Calculate scale to fit 90% of the smallest screen dimension for radius
        const max_dim = Math.min(w, h) * 0.45; 
        
        g_scale = max_dim / max_r_km; // New pixels per km scale
        
        drawAllElements();
    }
    
    /**
     * Draws or updates all SVG elements based on the current data and scale.
     */
    function drawAllElements() {
        if (!g_transferData) return;
        
        const data = g_transferData;

        // Central body radius updates with the new scale
        dom.centralBody.setAttribute('r', CURRENT_BODY_RADIUS_KM * g_scale);
        
        // Draw all three ellipses (initial, target, transfer)
        drawEllipse(dom.orbitInitial, data.r_p1_km, data.r_a1_km, g_scale);
        drawEllipse(dom.orbitTarget, data.r_p2_km, data.r_a2_km, g_scale);
        drawEllipse(dom.orbitTransfer, data.r_p_t_km, data.r_a_t_km, g_scale);
        
        // Draw burn points, scaling size by the Delta-V of the burn
        drawBurnPoint(dom.burn1, data.burn1_r_km, g_scale, data.burn1_isApoapsis, data.burn1_dv);
        drawBurnPoint(dom.burn2, data.burn2_r_km, g_scale, data.burn2_isApoapsis, data.burn2_dv);
    }

    /**
     * Draws an SVG ellipse representing an orbit.
     * The central body is at the focus (0,0). The ellipse is vertically oriented.
     * @param {Element} el - The SVG <ellipse> element.
     * @param {number} r_p_km - Periapsis radius (km).
     * @param {number} r_a_km - Apoapsis radius (km).
     * @param {number} scale - Pixels-per-km.
     */
    function drawEllipse(el, r_p_km, r_a_km, scale) {
        const r_p_px = r_p_km * scale;
        const r_a_px = r_a_km * scale;

        const a_px = (r_p_px + r_a_px) / 2; // Semi-major axis (vertical radius)
        const c_px = (r_a_px - r_p_px) / 2; // Distance from focus (center body) to ellipse center
        const e = (c_px / a_px) || 0; // Eccentricity
        const b_px = a_px * Math.sqrt(1 - e * e); // Semi-minor axis (horizontal radius)
        
        const cy_px = -c_px; // Center of ellipse Y-coord (Shifts center up so focus is at 0,0)
        
        el.setAttribute('cx', 0);
        el.setAttribute('cy', cy_px);
        el.setAttribute('rx', b_px); 
        el.setAttribute('ry', a_px); 
        el.style.display = 'block';
    }

    /**
     * Draws an SVG circle for a burn point.
     * @param {Element} el - The SVG <circle> element.
     * @param {number} r_km - Radius of the burn location (km).
     * @param {number} scale - Pixels-per-km.
     * @param {boolean} isApoapsis - True if burn is at apoapsis (y < 0), false if at periapsis (y > 0).
     * @param {number} dv - The Delta-V of the burn (m/s).
     */
    function drawBurnPoint(el, r_km, scale, isApoapsis, dv) {
        // Formula to scale radius: minimum radius + scaled DV
        const minRadius = 0; 
        const dvScaleFactor = 200; // 200 m/s for every 1 pixel increase in radius
        const radius_px = minRadius + (dv / dvScaleFactor);
        
        el.setAttribute('r', radius_px);
        
        const r_px = r_km * scale;
        const cy_px = isApoapsis ? -r_px : r_px; // Apoapsis on the negative Y axis
        
        el.setAttribute('cx', 0);
        el.setAttribute('cy', cy_px);
        el.style.display = 'block';
    }

    /**
     * The main transfer calculation function.
     */
    function calculateAndDraw() {
        clearResults(); 
        
        try {
            // --- 1. Get and Validate Inputs ---
            // Radii inputs are altitude, convert to radius from center later
            const r_p1_alt_km = parseFloat(dom.initPeriapsis.value);
            const r_a1_alt_km = parseFloat(dom.initApoapsis.value);
            const r_p2_alt_km = parseFloat(dom.targetPeriapsis.value);
            const r_a2_alt_km = parseFloat(dom.targetApoapsis.value);
            const finalMass_kg = parseFloat(dom.finalMass.value);
            const isp_s = parseFloat(dom.isp.value);
            
            // Basic input validation
            if ([r_p1_alt_km, r_a1_alt_km, r_p2_alt_km, r_a2_alt_km, finalMass_kg, isp_s].some(isNaN)) {
                throw new Error("All input fields must be valid numbers.");
            }
            if (r_a1_alt_km < r_p1_alt_km) throw new Error("Initial Apoapsis must be >= Initial Periapsis.");
            if (r_a2_alt_km < r_p2_alt_km) throw new Error("Target Apoapsis must be >= Target Periapsis.");
            if (r_p1_alt_km < 100 || r_p2_alt_km < 100) {
                 throw new Error("Orbits below 100km altitude are not stable.");
            }

            // Convert altitude (km) to radius (meters)
            const r_p1_m = (r_p1_alt_km + CURRENT_BODY_RADIUS_KM) * 1000;
            const r_a1_m = (r_a1_alt_km + CURRENT_BODY_RADIUS_KM) * 1000;
            const r_p2_m = (r_p2_alt_km + CURRENT_BODY_RADIUS_KM) * 1000;
            const r_a2_m = (r_a2_alt_km + CURRENT_BODY_RADIUS_KM) * 1000;

            // --- 2. Calculate Initial and Final Orbit Velocities ---
            const a1_m = (r_p1_m + r_a1_m) / 2; // Initial semi-major axis
            const a2_m = (r_p2_m + r_a2_m) / 2; // Target semi-major axis

            // Velocities at the four possible transfer points
            const v_i_p1 = getVelocity(r_p1_m, a1_m); 
            const v_i_a1 = getVelocity(r_a1_m, a1_m); 
            const v_f_p2 = getVelocity(r_p2_m, a2_m); 
            const v_f_a2 = getVelocity(r_a2_m, a2_m); 

            // --- 3. Calculate Two Possible Bi-tangential Transfers (Hohmann-style) ---
            
            // Scenario 1 (S1): Initial Periapsis (r_p1) to Target Apoapsis (r_a2)
            let dv1_s1 = Infinity, dv2_s1 = Infinity, total_dv_s1 = Infinity;
            let a_t1_m = 0;
            if (r_a2_m >= r_p1_m) { // Transfer is possible if r_a2 >= r_p1
                a_t1_m = (r_p1_m + r_a2_m) / 2; 
                const v_t_p1 = getVelocity(r_p1_m, a_t1_m); // Transfer vel at r_p1
                const v_t_a2 = getVelocity(r_a2_m, a_t1_m); // Transfer vel at r_a2
                
                dv1_s1 = Math.abs(v_t_p1 - v_i_p1);
                dv2_s1 = Math.abs(v_f_a2 - v_t_a2);
                total_dv_s1 = dv1_s1 + dv2_s1;
            }

            // Scenario 2 (S2): Initial Apoapsis (r_a1) to Target Periapsis (r_p2)
            let dv1_s2 = Infinity, dv2_s2 = Infinity, total_dv_s2 = Infinity;
            let a_t2_m = 0;
            if (r_a1_m >= r_p2_m) { // Transfer is possible if r_a1 >= r_p2
                a_t2_m = (r_a1_m + r_p2_m) / 2; 
                const v_t_a1 = getVelocity(r_a1_m, a_t2_m); // Transfer vel at r_a1
                const v_t_p2 = getVelocity(r_p2_m, a_t2_m); // Transfer vel at r_p2

                dv1_s2 = Math.abs(v_t_a1 - v_i_a1);
                dv2_s2 = Math.abs(v_f_p2 - v_t_p2);
                total_dv_s2 = dv1_s2 + dv2_s2;
            }

            // --- 4. Select Best Transfer (Minimum Delta-V) ---
            let best_dv1, best_dv2, best_total_dv, transferType, a_t_m;
            let r_A, r_D, v_A_initial, v_D_final; // Burn radii and velocities for Bi-elliptic check

            if (total_dv_s1 === Infinity && total_dv_s2 === Infinity) {
                throw new Error("No co-axial bi-tangential transfer is possible (orbits cross).");
            }

            if (total_dv_s1 <= total_dv_s2) {
                // S1 is the optimal Hohmann-style transfer
                best_dv1 = dv1_s1;
                best_dv2 = dv2_s1;
                best_total_dv = total_dv_s1;
                transferType = "Periapsis \u2192 Apoapsis";
                a_t_m = a_t1_m;
                r_A = r_p1_m; v_A_initial = v_i_p1;
                r_D = r_a2_m; v_D_final = v_f_a2;
                g_transferData = {
                    r_p1_km: r_p1_m / 1000, r_a1_km: r_a1_m / 1000,
                    r_p2_km: r_p2_m / 1000, r_a2_km: r_a2_m / 1000,
                    r_p_t_km: r_p1_m / 1000, r_a_t_km: r_a2_m / 1000,
                    burn1_r_km: r_p1_m / 1000, burn1_isApoapsis: false, burn1_dv: best_dv1,
                    burn2_r_km: r_a2_m / 1000, burn2_isApoapsis: true,  burn2_dv: best_dv2,
                };
            } else {
                // S2 is the optimal Hohmann-style transfer
                best_dv1 = dv1_s2;
                best_dv2 = dv2_s2;
                best_total_dv = total_dv_s2;
                transferType = "Apoapsis \u2192 Periapsis";
                a_t_m = a_t2_m;
                r_A = r_a1_m; v_A_initial = v_i_a1;
                r_D = r_p2_m; v_D_final = v_f_p2;
                g_transferData = {
                    r_p1_km: r_p1_m / 1000, r_a1_km: r_a1_m / 1000,
                    r_p2_km: r_p2_m / 1000, r_a2_km: r_a2_m / 1000,
                    r_p_t_km: r_p2_m / 1000, r_a_t_km: r_a1_m / 1000,
                    burn1_r_km: r_a1_m / 1000, burn1_isApoapsis: true,  burn1_dv: best_dv1,
                    burn2_r_km: r_p2_m / 1000, burn2_isApoapsis: false, burn2_dv: best_dv2,
                };
            }

            // --- 5. Rocket Equation & Transfer Time ---
            const ve = isp_s * G0; // Effective exhaust velocity (m/s)
            const massRatio = Math.exp(best_total_dv / ve);
            const initialMass_kg = finalMass_kg * massRatio;
            const propellantMass_kg = initialMass_kg - finalMass_kg;
            
            // Transfer time is half the period of the transfer ellipse
            const transfer_time_s = Math.PI * Math.sqrt(Math.pow(a_t_m, 3) / CURRENT_GM_M3_S2);
            const transfer_time_min = transfer_time_s / 60.0;

            // --- 6. Update UI Display ---
            dom.typeVal.textContent = transferType;
            dom.dv1Val.textContent = `${best_dv1.toFixed(1)} m/s`;
            dom.dv2Val.textContent = `${best_dv2.toFixed(1)} m/s`;
            dom.totalDvVal.textContent = `${best_total_dv.toFixed(1)} m/s`;
            dom.timeVal.textContent = `${transfer_time_min.toFixed(1)} min`;
            
            dom.propMassVal.textContent = `${propellantMass_kg.toFixed(1)} kg`;
            dom.initMassVal.textContent = `${initialMass_kg.toFixed(1)} kg`;

            // --- 7. Draw Visualization ---
            updateScaleAndRedraw();
            
            // --- 8. Bi-elliptic Transfer Check ---
            const r_outer_m = Math.max(r_A, r_D);
            const mu = CURRENT_GM_M3_S2;
            const total_dv_Hohmann = best_total_dv;

            // Calculate Delta-V for a bi-parabolic (escape/re-capture) transfer, 
            // which is the limit of the bi-elliptic transfer as the intermediate radius goes to infinity.
            const v_escape_A = getVelocity(r_A, Infinity);
            const v_escape_D = getVelocity(r_D, Infinity);
            const total_dv_BiParabolic = Math.abs(v_escape_A - v_A_initial) + Math.abs(v_escape_D - v_D_final);


            if (total_dv_BiParabolic < total_dv_Hohmann) {
                
                if (Math.abs(total_dv_BiParabolic - total_dv_Hohmann) < 0.1) {
                    // Crossover point is near infinity (Bi-parabolic DV is slightly lower)
                    dom.biEllipticWarning.className = 'warning amber';
                    dom.biEllipticWarning.innerHTML = `BI-ELLIPTIC WARNING: <br> The bi-tangential transfer DV is nearly identical to a bi-parabolic (infinite) transfer. <br> A bi-elliptic transfer is theoretically more efficient, but requires a near-infinite transfer apoapsis and transfer time.`;
                    dom.biEllipticWarning.style.display = 'block';

                } else {
                    // Check if *any* bi-elliptic transfer is better than the selected Hohmann transfer
                    const dv_at_low_rb = getBiEllipticDV(r_A, v_A_initial, r_D, v_D_final, r_outer_m * 1.01, mu);

                    if (dv_at_low_rb < total_dv_Hohmann) {
                        // All valid bi-elliptic transfers are more efficient.
                        dom.biEllipticWarning.className = 'warning amber';
                        dom.biEllipticWarning.innerHTML = `BI-ELLIPTIC WARNING: <br> For this transfer, **any bi-elliptic transfer** (with an apoapsis > ${(r_outer_m/1000).toFixed(0)} km) will be more fuel-efficient than this bi-tangential transfer.`;
                        dom.biEllipticWarning.style.display = 'block';

                    } else {
                        // The crossover point for efficiency is at a finite, large radius. Find the breakeven point using bisection.
                        const diff_func = (rb) => getBiEllipticDV(r_A, v_A_initial, r_D, v_D_final, rb, mu) - total_dv_Hohmann;
                        
                        let low = r_outer_m * 1.01; 
                        let high = r_outer_m * 100; 
                        
                        // Increase search space until the bi-elliptic DV is better than Hohmann DV
                        while (diff_func(high) > 0 && high < 1e15) {
                            high *= 10; 
                        }

                        if (diff_func(high) < 0) {
                            // Run bisection to converge on the breakeven radius
                            for (let i = 0; i < 50; i++) { 
                                let mid = (low + high) / 2;
                                if (diff_func(mid) < 0) { 
                                    high = mid;
                                } else { 
                                    low = mid;
                                }
                            }
                            
                            const breakeven_rb_m = high;
                            const breakeven_rb_alt_km = (breakeven_rb_m / 1000) - CURRENT_BODY_RADIUS_KM;
                            const transfer_time_s = getBiEllipticTime_s(r_A, r_D, breakeven_rb_m, mu);
                            const transfer_time_days = transfer_time_s / 60.0 / 60.0 / 24.0;

                            // Format the altitude for readability
                            const rounded_breakeven_alt_km = Math.ceil(breakeven_rb_alt_km / 500) * 500;
                            const formatted_alt_km = rounded_breakeven_alt_km.toLocaleString('en-US');

                            dom.biEllipticWarning.className = 'warning amber';
                            dom.biEllipticWarning.innerHTML = `BI-ELLIPTIC WARNING: <br> A bi-elliptic transfer will be more efficient **only if** its apoapsis altitude is > **${formatted_alt_km} km**. <br> A transfer at that break-even altitude would take **${transfer_time_days.toFixed(1)} days**.`;
                            dom.biEllipticWarning.style.display = 'block';

                        } else {
                            // Should only happen if the breakeven point is beyond 1e15 meters
                            dom.biEllipticWarning.className = 'warning amber';
                            dom.biEllipticWarning.innerHTML = `BI-ELLIPTIC WARNING: <br> A bi-elliptic transfer *may* be more efficient, but requires an extremely large transfer apoapsis.`;
                            dom.biEllipticWarning.style.display = 'block';
                        }
                    }
                }
            }


        } catch (err) {
            // Display calculation errors to the user
            dom.warning.className = 'warning red';
            dom.warning.textContent = `ERROR: ${err.message}`;
            g_transferData = null; 
        }
    }

    // --- Start Application ---
    init();

</script>
</body>
</html>